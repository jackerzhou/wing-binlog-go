package main

import (
	"regexp"
	//"bytes"
	"log"
	"bytes"
)

//var expRenameTable = regexp.MustCompile("(?i)^RENAME\\sTABLE\\s.*?(`{0,1}(.*?)`{0,1})?\\.?`{0,1}(.*?)`{0,1}TO\\s.*?\\.{0,1}`{0,1}([^`\\.]+?)`{0,1}$")
//\\s.*?`{0,1}(.*?)`{0,1}\\.{0,1}`{0,1}([^`\\.]+?)`{0,1}
//var expRenameTable = regexp.MustCompile("(?i)^RENAME\\sTABLE.*TO\\s.*?`{0,1}(.*?)`{0,1}\\.{0,1}`{0,1}([^`\\.]+?)`{0,1}$")
//var expRenameTable = regexp.MustCompile("(?i)^RENAME\\sTABLE.*TO\\s.*?`{0,1}(.*?)`{0,1}\\.{0,1}`{0,1}([^`\\.]+?)`{0,1}$")
var expRenameTable = regexp.MustCompile("(?i)^RENAME\\sTABLE\\s.*?`{0,1}(.*?)`{0,1}\\.{0,1}`{0,1}([^`\\.]+?)`{0,1}\\s{1,}TO\\s.*?")
var expDropTable   = regexp.MustCompile("(?i)^DROP\\sTABLE\\s.*?`{0,1}(.*?)`{0,1}\\.{0,1}`{0,1}([^`\\.]+?)`{0,1}($|\\s)")

//var expRenameTable = regexp.MustCompile("(?i)^RENAME\\sTABLE\\s.*?`{0,1}(.*?)`{0,1}\\s.*?TO\\s.*?")
func main()  {
	cases := []string{
		"rename table `mydb`.`mytable` to `mydb`.`mytable1`",
		"rename table `mytable` to `mytable1`",
		"rename table mydb.mytable to mydb.mytable1",
		"rename table mytable to mytable1",

		"rename table `mydb`.`mytable` to `mydb`.`mytable2`, `mydb`.`mytable3` to `mydb`.`mytable1`",
		"rename table `mytable` to `mytable2`, `mytable3` to `mytable1`",
		"rename table mydb.mytable to mydb.mytable2, mydb.mytable3 to mydb.mytable1",
		"rename table mytable to mytable2, mytable3 to mytable1",
	}
	table := []byte("mytable")
	db := []byte("mydb")

	for _, s := range cases {
		m := expRenameTable.FindSubmatch([]byte(s))
		if m!= nil {
			for _, v := range m {
				log.Println(string(v))
			}
		}
		if m == nil || !bytes.Equal(m[2], table) || (len(m[1]) > 0 && !bytes.Equal(m[1], db)) {
			log.Fatalf("TestRenameTableExp: case %s failed\n", s)
		}
		log.Println("==========================")
	}

	cases = []string{
		"drop table test1",
		"DROP TABLE test1",
		"DROP table test.test1 IF EXISTS test.test1",
		"drop table `test1`",
		"DROP TABLE `test1`",
		"DROP table `test`.`test1` IF EXISTS `test`.`test1`",
		"DROP TABLE `test1` /* generated by server */",
	}

	table = []byte("test1")
	//db := []byte("test1")
	for _, s := range cases {
		m := expDropTable.FindSubmatch([]byte(s))
		if m!= nil {
			for _, v := range m {
				log.Println(string(v))
			}
		}
		if m == nil || !bytes.Equal(m[2], table) {
			log.Fatalf("TestRenameTableExp: case %s failed\n", s)
		}
		log.Println("==========================")
	}
}
